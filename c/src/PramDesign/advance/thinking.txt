第一章 绪论
1、什么是计算机？
本质是程序的机器
2、计算机语言发展
时间：机器语言-汇编语言（符号语言）-高级语言（FORTRAN、C\C++、Java、python）
逻辑：非结构化语言-结构化语言-面向对象语言
3、c语言及其特点？
 8个优点。语言简练、执行速度块、操作内存、操作丰富等等
4、c语言编译流程？
 源程序（.c)-预编译-S（.i)-编译-S（.s)-汇编-C（.o)-链接（.exe)
 预编译：处理注释，以空格代替。删除#define，展开所有宏定义。处理条件编译指令。
       处理#include，展开包文件。保留编译器需要的#pragma指令
 编译：对预处理文件进行词法分析、语法分析和语义分析
 汇编：将代码转化为机器可识别的指令。
 链接：将执行文件需要的其他文件依赖链接起来构成一个完整的可执行文件。
源程序：指未编译的，按照一定的程序设计语言规范书写的文本文件。
目标程序：指源程序经编译可直接被计算机运行的机器码集合（二进制代码），扩展名“.obj”。
可执行程序：目标程序与库函数连接，形成的完整的可在操作系统下独立执行的程序。
第二章
1、什么是算法？
 程序=数据结构+算法。
 算法：操作数据的方法。
2、算法的特性？
 有穷性、确定性、有限的输入输出、有效性等。
3、流程图的基本结构？
 顺序结构、选择结构、循环结构
第三章 数据类型
1、c语言数据类型
 基本类型（short、int、long、char、float、double、bool）
   基本类型：常量、符号常量、变量、常变量
      常量：不分配内存，值不能改变。
      符号常量:#define PI 3.14  在预编译阶段对其进行处理将其替换
      符号常量的作用？
      相比与普通常量，符号常量会使得代码易读，一改全改。
    变量：分配空间，可以在静态存储区、可以在堆中、可以在栈中
    常变量：const修饰，分配内存，但不能改其值。分配内存可能是静态区，也可能是栈。
    标识符：数字、字母、下划线、字母不能大头、区分大小写
   **const修饰的变量必须初始化；
     const出现在*左边表示指针指向的数据为常量，出现在*右边表示指针本身为常量。同时出现，二者都是常量。
     const定义形参表示不会修改实参的值
 派生类型（数组、结构体类型、共用体类型、链表、函数类型、 指针类型）
 枚举类型：
 空类型：（void）
2、整型数据
  基本整型（int）2、4
   短整型（short int、int）2
   长整型（long int 、long）4
   双长整型（long long int 、long long） 8
 无符号整型：unsigned
3、字符与字符代码
  字符变量  1字节
   char a='A'; printf("%d",a);输出A的ASCALL吗的值65
   char a='A'; printf("%c",a);输出字符A
   char a=65; printf("%c",a);输出A
   char a=65; printf("%d",a);输出65
 4、浮点数（编译器将小数默认按double处理）
  float a=3.1415f;合理不加f则向下转型损失精度
  double   保证15位有效数字
  long double
 ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
第三章 C语句
  printf输出格式
 scanf("a=%d,b=%d,c=%d",&a,&b,&c);  输入时必须按照a=1,b=2,c=3  输入
 输入输出字符：
  getchar与putchar，只能输出一个字符，多输入只读取一个。不能输出字符串。
第四章 选择结构程序
   while的特点：先判断条件表达式，后执行循环体。
   do{……}while的特点：先执行do，在判断
   for循环执行顺序：先执行表达式1，再执行表达式2，然后执行循环体，执行表达式3，然后判断表达式2.
   break与countinue、return
 
第六章 数组
1、数组？
  定义：数组是统一类型的有序数据的集合。
  一维数组：
  创建：int a[n*2] 合法  static int a[n*2] 不合法
            int a[10]; 
            int a[]={1，2}；一定要初始化，因为不初始化不能分配空间。
  引用：
      变量名引用：变量名[下标]、*（变量名+索引数）（地址引用）
       地址引用：地址[下标]、*（地址+索引数）
  二维数组：
   创建：float a[3][6]；
               float a[3][6]={1.0,2.0,3.0,4.0,6.0};
               float a[3][6]={{1.0,2.0,3.0},{4.0,6.0}};
   引用：
      变量名索引：变量名[下标1][下标2] 、  *（*（变量名+索引数）+索引数））  **注意对应第二种方式要想索引其值必须有两个**
      地址引用：按一维数组处理。 地址[下标1x列数+下标2]、*地址(下标1x列数+下标2)     
  字符数组：
     创建：
         char a[10];
         char a[];  必须初始化
     引用：
      和数字数组一样
  字符串数组：
     定义：将字符串当作字符数组处理，因此变量名为地址。结尾有'\0'标志，不显示，也可以不以'\0'结尾
     创建：
          char c[]={"hello word"};
          char c[]="hello word";
          等价于：char c[]={'h','e','l',……,'d','\0'} 也可以不以'\0'结尾
      输入输出：puts（str） gets（str）只能输入输出一个字符串
       字符串链接：strcat（str1，str2）把2连到1上
       字符串复制：strcpy（str1，str2）
        字符串比较：strcmp
        字符串长度：strlen
         转换为小写：strlwr
         转化为大写：strupr
       %s格式可以依次处理数组字符知道遇到\0；可以像数组一样索引；
     char a[6]="hello";  a[1]为e
2、数组的存储？
 一维数组的存储：
 数组是一串连续地址存储的数据。数组名等于首地址。移动地址时以数据类型为单元移动。
 如，int数组，移动则以4个字节移动
 二维数组存储：
 将二维数组看出特殊的一维数组。不同的是，将二维数组的每一行拆分，看成一维数组处理。


第七章 函数
1、函数是什么？
  函数就是一种功能。
2、函数定义？
 返回值类型 函数名（参数1，参数2....）{}
3、函数怎么执行
   函数只会将传递的参数复制，并不改变实参的值。
4、函数的调用？
   被调用函数在调用参数后面，则需要申明（返回值类型 函数名（参数1，参数2....））。被static修饰的函数只能被本文件调用。
   
5、主函数理解
  1、为什么主函数类型是int
   因为可以通过返回值确认程序是否被正常执行，返回0表示正常退出。
   且返回值能传递给程序调用者（如操作系统）。c99对没有加return的会自动加上。
 6、主函数参数
   int main（int argc char *argv[]）{}  第一个是参数数量，第二个是字符串
   作用：可以在程序运行前作判断，对代码做出控制。
7、空函数的作用？
 函数占位，便于扩充。
8、函数传参
   基本数据传参，不改变其值
   数组传参：形参和实参一致，改变值
        一维数组传参：
            数组元素传参：和基本数据传参一致
            数组名传参：传递的是数组首地址
                   由于c语言并不检查形参大小，因此函数形参不设大小为  类型 变量名[](),必须接[]
       多维数组传参：
            多为数组中形参第二个下标把必须有数  int a[][10]与Int a[3][10]  正确  int a[][] 错误
9、局部变量、静态局部变量、全局变量、静态全局变量？
10、动态存储、静态存储
      动态存储：局部变量、寄存器变量（cpu）、形式参数
      静态存储：静态局部变量、全局变量、静态全局变量
****11、寄存器与缓存？？？？？？？？？
12、extern？？？？
13、多文件函数调用与编译
     多文件函数调用有两种方式：
     1、在头文件中声明函数  声明类型 变量名（类型 变量名），然后调用头文件从而进行调用函数，但要 gcc 编译多个.c文件
     2、gcc直接编译多个文件
14、gcc编译？？


第八章 指针

1、赋值
  变量给指针赋值在变量名前加&
  数组名为数组首地址不需要加&
   *p=a与p=&a本质上不一样，前者是赋值，后者是赋地址
  &：取地址运算符
  *：指针运算符
2、数组存储地址索引与传参地址索引
  一维数组：索引参考第六章数组
  **sizeof(数组名)表示求整个数组的字节；sizeof（数组赋予的指针p）表示指针的字节，32位为4，64位为8；
    
3、字符串指针
   字符串指针和数组操作一致，需要注意的是字符串数组最后有\0。
4、指向函数的指针、函数指针、指针函数
   指向函数的指针：定义一个指针，将函数地址赋给指针
      和数组操作类似。但又不同，数组地址的下一地址为数据，而函数指针的下一个为指令。
     调用？
       定义：int max（int x，int y）  
                int （*p）（int，int）  注意定义的类型***
                  p=max；
        调用：（*p）（参数列表）*****
       ****这种类型将函数一般化，并不能直接构建函数。如int （*p）（int x，int y）{……}是错误的；
              只能给他赋值，如定义的例子，又比当作另一个函数的形参，如int test(int (*p)(int,int),int b)
   指针函数：
       定义：返回指针
             类型名  *函数名（参数列表）  
              int *p（）指针函数,可以直接构建函数，并返回指针。  
          int （*p)()为指向函数的指针
    
5、函数指针的用途？
  前面讲的指针是为了通过指针找到相应的地址值便于操作。而函数指针的存在主要是
  将类型相似的多个函数进行一般化处理，根据条件进行函数地址赋值。例M（int a,int b)
  N(int a,int b) 与*p（int int）在条件a下p=M，在条件b下p=N。
6、多重指针
   指针数组：其元素为指针 
       一维数组：
       定义：int *p[]    []优先级高于*，[]先与p结合     int （*p)[]是一维数组指针
            举例：char *p[]={"h","e"};
    指向指针的指针：
       定义：
          int  **p
 
7、动态内存分配
    malloc（size)  返回指针
   calloc（n*size)
    free(指针）
   realloc（指针，空间大小） 返回指针
  （1）void *malloc（unsigned int size)
   开辟一维数组：

   开辟二维数组：

9 int int* int**的区别？
  int** p;
  p,p+1,*p+1,*(p+1),**p,**p+1,**(p+1),*(*p+1),**(p+1)的区别？
10、void 指针
   指向空类型，可以强制转换成其他类型。
11、指针数组与数组指针？
12、指针函数与函数指针？
13、int 、int*、int**？？


第九章 

1、结构体
  定义：struct 结构体类型名{成员列表} 变量名1，变量名2；
       typedef  struct 结构体类型名{成员列表} 结构体名；将结构体重新赋名字，可以简化编程，易读。
  创建：
    初始化：1、 struct 结构体类型名{成员列表} 变量名={成员值}；
                   2、struct 结构体类型名{成员列表} 变量名；变量名.成员=值；
                       .是成员运算符，在所有运算符中最高级
                   3、结构体数组:
                       struct 结构体类型名{成员列表} 数组名[num]；
                       表示包含num组结构体数据
                     初始化：
               编译时不对结构体类型名分配空间，只对变量名分配空间。和int等类似。        
     动态创建：struct 结构体名 *p=(struct 结构体名 *）malloc（sizeof（struct 结构体名 ))
  引用：
       变量名引用：变量名.成员
       指针引用：指针->成员
          ->称为指向运算
     ****结构体只能在全局变量里初始化，对结构体成员赋值、调用需要到函数中。
  
  存储：连续空间
  指针和引用：结构体的指针引用与数组略有不同。如结构体变量代表首元素地址这和数组一致，但
      不同的是若结构体首元素是基本数据类型，则要在变量名前加&。如果首元素是基本数据类型
      但变量是数组类型，则按数组类型处理。变量名前不需要添加&。
      例struct A a；struct A b[]；struct A *p；这里不考虑首元素为基本类型。
      p=a时*（p）.属性。p=b时，p->属性。
  
2、链表
  定义：  struct S{成员
        struct S *next;
  }
  静态链表、动态链表：用函数创建链表为动态链表
  3、共用体
      定义：
         union 共用体类型名字{成员} 变量名；
      初始化：
         
      引用：
         变量名.成员
      存储：
        共用一段存储空间，但在某一时刻只能放一个成员，放多个则会报错。

  4、枚举
        定义：
           enum[枚举名]{枚举元素列表} 变量名；
           编译器将枚举元素按常量处理，因此不能赋值。

  5、typedef、typeof

  第十章 文件
  1、什么是文件？
    程序文件、数据文件。是存储在外部介质上的数据。
  2、文件读写过程-文件缓冲区
    文件的读写主要指内存对磁盘文件的写入与读取。在交互的过程中，存在一个文件缓冲区，
    在读写时，数据装满缓冲区后才会读写操作，称为全缓冲。此外还有、行缓冲、无缓冲。
    若使用全缓冲或者行缓冲则有可能造成未达到数据要求而不进行读取，因此对文件操作完
    之后需要关闭文件。这样就会对缓冲区未读写的文件进行处理。
  2、文件指针
    文件指针由结构体定义，包含文件存储信息。
    定义：FILE *p；
  3、文件的读取与写入操作
      文件打开：
           fopen（路径/文件名，使用文件方式）； 返回一个指针。
               使用文件方式：
                  "r"-cpu读取  'w'-cpu写入，可以建立新文件   'a'-向文本文件为添加数据  "rb"-读取二进制文件，"r+"-？？
      文件关闭：
          fclose（文件指针）；可以处理缓冲区为写入、写出数据。
4、向文件读写字符
    读取-用户：
         fgetc（文件指针）
     写入-用户：
       fputc（ch，文件指针）
5、向文件读写字符串
     读取-用户：
      fgets（str，n，文件指针）；读取n-1长度字符串，返回到str并附加'\0'
     写入：
       fputs（str，文件指针）
6、格式化方式读写
7、二进制读写
8、随机读写
9、文件读写出错
   

第十一章

1、模块化编程
   https://blog.csdn.net/as480133937/article/details/93400979
2、makefill怎么实现？
  https://www.cnblogs.com/JohnABC/p/4568459.html
3、extern的作用？
  https://www.zhihu.com/search?type=content&q=c%E8%AF%AD%E8%A8%80%E9%94%81extern
4、const的作用？
  1、保护数据，避免意外修改
  2、便于编译器处理，提高效率。比如const修饰的常量编译器不会分配空间，而是将它保存在符号表中，没有存储和读取的操作。
5、宏定义与头文件编译
   https://blog.csdn.net/kangjialong_/article/details/121107992
   头文件：https://blog.csdn.net/m0_61754391/article/details/120257277
   
6、c语言多线程与锁以及锁的实现？
  1、多线程：
     依赖：#include<pthread.h>
     创建：pthread_create (thread, attr, start_routine, arg)
     退出：pthread_exit(NULL);
     **编译：pthread 不在 Linux 系统默认的库中，链接时需要使用 libpthread.a这个静态库
       在使用pthread_create()创建线程，调用 pthread_atfork()函数建立fork处理程序时，都需要链接libpthread.a这个库。
     解决方法：
     编译时加入-lpthread这个参数即可
     gcc thread.c -o thread -lpthread
  锁：https://www.zhihu.com/search?type=content&q=c%E8%AF%AD%E8%A8%80%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0
7、c语言面向对象
   1、封装：在头文件中声明结构体和操作方法，在源文件中调用。
   2、继承：声明新的结构体，用原来结构体定义属性，实现了继承。再定义自己的属性和操作方法。
   3、多态：
9、assert
  
10、简述数组与指针的区别？
   数组要么在静态存储区被创建，要么在栈上被创建。指针可以随时指向认一内存块。
   **静态存储区与动态存储区：
     作用角度：全局、局部变量
     生存期：
       静态：分配固定地址，存储全局变量与静态局部变量（static修饰）
       动态存储：更具需要分配地址，函数形参、函数局部变量、
     用户存储空间：程序区、静态区、动态区
     **栈、堆、静态区
       栈：保存函数维护信息调用上下文函数参数和局部变量存储、返回地址
       堆：是程序预留空间，可自由使用，在堆中申请内存在释放前一直有效。
        ？？有了栈为什么还要堆？
           栈上的数据在函数返回后就会被释放掉，无法传递到函数外部，如局部数组。
           malloc以字节方式申请堆空间，free将堆空间还给系统
        系统对堆的管理方式？
          空闲链表法、位图法、对象池法
        静态存储区：随着程序运行分配空间，直到程序执行完毕结束。在编译期静态存储区大小确定，主要保存全局变量和
           静态局部变量，信息最终会保存到可执行程序中。
    总结：栈、堆、静态存储区是程序基本三个数据区
        栈主要用于函数调用
        堆主要用于内存的动态申请与归还
        静态存储区存放全局、静态局部变量
        **esp、ebp  通过这两个指针可以确定函数调用依次的信息单元。
          esp：栈指针，存放指针永远指向系统栈最上面一个栈帧的栈顶（低地址）。
          ebp：…  的底部（高地址）。
          **系统栈：
            栈帧：在栈中存储函数调用相关信息
            栈帧的启示：栈帧上的动态内存分配、函数调用深度、栈的回溯
11、C中int8_t、int16_t、int32_t、int64_t、uint8_t、size_t、ssize_t区别
   https://blog.csdn.net/yz930618/article/details/84785970/
12、C语言中volatile关键字用法
  https://blog.csdn.net/breadheart/article/details/114450275
  https://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&mid=2247492425&idx=1&sn=956fdd05872fdb45aa5a111bc289e67a&chksm=e9e7c878de90416e00f16a6c741dff6aeff531134e5cad3481b9bb9152079e00eaa994f27f5b&scene=21#wechat_redirect
  编译器优化：
  高速缓存：
  volatile 关键字(keywords)是一种类型修饰符(Type Qualifiers)，volatile 的英文翻译过来是 “易变的” 。
  用volatile 声明类型变量的时候，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；
  如果不使用 volatile 进行声明，则编译器将对所声明的语句进行优化。即 volatile 关键字影响编译器编译的结果，
  用 volatile 声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。
13、void函数类型
  无效和空白的含义。它的作用：虚函数返回类型、虚函数作为功能参数、空指针声明
  1、修饰指针-无效指针：空指针（void *）是没有关联数据类型的指针。空指针可以保存任何类型的地址，并且可以将其类型转换为任何类型。默认不能++，原因是指向的void类型不知大小
  2、修饰函数-虚函数返回类型  执行函数时，无效返回类型不返回值。 void method（）
  3、不能修饰变量，因为大小未知
  **sizeof（int*），sizeof（double *），sizeof（void*）的大小是一样的，原因很简单，这个是一个指针，指针里面存储的是一个地址，而地址只跟我们的寻址总线有关，比如32位的地址总线，就是占32位，默认来说，地址的大小，跟sizeof（int）是一致的，系统默认遵循，int的占用空间，跟地址总线一致。
14、sizeof(char)为1，sizeof(‘a’)为4转化为int，sizeof（”a“）为2除了a还有\0
15、栈溢出会发生什么？内存溢出？

16、指针数组与数组指针、指针函数与函数指针
17、GDB调试
18、线程间的同步与互斥的区别与联系
19、git命令   
